<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><title>Untitled Document.md</title>
  <style>
    body * { font-family: 'Times New Roman'; font-size: 14pt; text-align: justify;}
    h1 { font-size: 16pt; }
    h1, h2, h3, h4 { font-weight: bold;}
    p { margin-left: 1.25em; }
  </style>
</head>
<body>
<h1 id="-">Введение</h1>
<p>Задача настоящей работы – создание базы данных для веб-ресурса. В качестве веб-ресурса рассмотрим веб-сервис <a href="http://smartreserve.by">smartreserve.by</a>, предназначенный для бронирования мест в ресторанах в режиме онлайн, написанный на фреймворке Ruby on Rails и использующий СУБД PostgreSQL.</p>
<h2 id="-">История развития баз данных</h2>
<p>Информационная система представляет собой программно-аппаратный комплекс, обеспечивающий выполнение следующих функций:</p>
<ul>
<li>надёжное хранение информации в памяти компьютера;</li>
<li>выполнение специфических преобразований информации и вычислений;</li>
<li>предоставление пользователям удобного и легко осваиваемого интерфейса.</li>
</ul>
<p>Обычно такие системы имеют дело с большими объемами информации, имеющей достаточно сложную структуру. Классическими примерами информационных систем являются банковские системы, автоматизированные системы управления предприятиями, системы резервирования авиационных или железнодорожных билетов, мест в гостиницах и т.д. и т.п. Эта (вторая) область использования вычислительной техники возникла несколько позже первой, т.к. на заре вычислительной техники возможности компьютеров по хранению информации были очень ограниченными.</p>
<p>В первых компьютерах использовались два вида устройств внешней памяти – магнитные ленты и барабаны (что, как мы увидим, наложило свой серьёзный отпечаток на способы физического хранения данных в БД). Ёмкость магнитных лент была достаточно велика, но по своей физической природе они обеспечивали последовательный доступ к данным. Магнитные барабаны (они ближе всего к современным магнитным дискам с фиксированными головками) давали возможность произвольного доступа к данным, но имели малый объём хранимой информации. Эти ограничения не являлись слишком существенными для чисто численных расчётов. 
Даже если программа должна обработать (или произвести) большой объем информации, при программировании можно продумать расположение этой информации во внешней памяти (например, на последовательной магнитной ленте), обеспечивающее эффективное выполнение этой программы.</p>
<p>Однако в информационных системах совокупность взаимосвязанных информационных объектов фактически отражает модель объектов реального мира, а потребность пользователей в информации требует быстрой реакции системы на их запросы. И в этом случае наличие сравнительно медленных устройств хранения данных, к которым относятся магнитные ленты и барабаны, было недостаточным.</p>
<p>С появлением магнитных дисков началась история систем управления данными во внешней памяти. До этого каждая прикладная программа, которой требовалось хранить данные во внешней памяти, сама определяла расположение каждой порции данных на магнитной ленте или барабане и выполняла обмены между оперативной памятью и устройствами внешней памяти с помощью программно-аппаратных средств низкого уровня (машинных команд или вызовов соответствующих программ операционной системы). Такой режим работы не позволяет или очень затрудняет поддержание на одном внешнем носителе нескольких архивов долговременно хранимой информации. Кроме того, каждой прикладной программе приходилось решать проблемы именования частей данных и структуризации данных во внешней памяти.</p>
<p>Важным шагом в развитии именно информационных систем явился переход к использованию централизованных систем управления файлами. С точки зрения прикладной программы, файл – это именованная область внешней памяти, в которую можно записывать и из которой можно считывать данные.
На смену файлам пришли потоки данных. Фактически, с точки зрения программы, это те же файлы, которые «в реальности» могут быть сокетами, «обёртками» различных сетевых протоколов или внешних аппаратных устройств. Правила именования файлов, способ доступа к данным, хранящимся в файле, и структура этих данных зависят от конкретной системы управления файлами и, возможно, от типа файла.</p>
<p>Система управления файлами берёт на себя распределение внешней памяти, отображение имён файлов в соответствующие адреса во внешней памяти и обеспечение доступа к данным. Пользователи видят файл как линейную последовательность записей и могут выполнить над ним ряд стандартных операций:</p>
<ul>
<li>создать файл (требуемого типа и размера);</li>
<li>открыть ранее созданный файл;</li>
<li>прочитать из файла некоторую запись (текущую, следующую, предыдущую, первую, последнюю);</li>
<li>записать в файл на место текущей записи новую, добавить новую запись в конец файла.</li>
</ul>
<p>Главное, что следует отметить, – это то, что структура записи файла была известна только программе, которая с ним работала, система управления файлами не знала её. И поэтому для того, чтобы извлечь некоторую информацию из файла, необходимо было точно знать структуру записи файла с точностью до бита. Каждая программа, работающая с файлом, должна была иметь у себя внутри структуру данных, соответствующую структуре этого файла. Такая ситуации характеризовалась как зависимость программ от данных.</p>
<p>Для информационных систем характерным является наличие большого числа различных пользователей (программ), каждый из которых имеет свои специфические алгоритмы обработки информации, хранящейся в одних и тех же файлах. Изменение структуры файла, которое было необходимо для одной программы, требовало исправления и перекомпиляции и дополнительной отладки всех остальных программ, работающих с этим же файлом. Это было первым существенным недостатком файловых систем, который явился толчком к созданию новых систем хранения и управления информацией. Далее, поскольку файловые системы являются общим хранилищем файлов, принадлежащих разным пользователям, системы управления файлами должны обеспечивать авторизацию доступа к файлам.</p>
<p>В общем виде подход состоит в том, что по отношению к каждому зарегистрированному пользователю данной вычислительной системы для каждого существующего файла указываются действия, которые разрешены или запрещены данному пользователю. В большинстве современных систем управления файлами применяется подход к защите файлов, впервые реализованный в ОС UNIX. Для множества файлов, отражающих информационную модель одной предметной области, децентрализованный принцип управления доступом вызывал дополнительные трудности. Отсутствие централизованных методов управления доступом к информации послужило ещё одной причиной разработки СУБД.</p>
<p>Следующей причиной стала необходимость обеспечения эффективной параллельной работы многих пользователей с одними и теми же файлами. Если операционная система поддерживает многопользовательский режим, вполне реальна ситуация, когда два или более пользователя одновременно пытаются работать с одним и тем же файлом. </p>
<p>Если все пользователи собираются только читать файл, ничего страшного не произойдёт. Но если хотя бы один из них будет изменять файл, для корректной работы этих пользователей требуется взаимная синхронизация их действий по отношению к файлу.</p>
<p>В системах управления файлами обычно применялся следующий подход. В операции открытия файла (первой и обязательной операции, с которой должен начинаться сеанс работы с файлом) среди прочих параметров указывался режим работы (чтение или изменение). Если к моменту выполнения этой операции некоторым пользовательским процессом PR1 файл был уже открыт другим процессом PR2 в режиме изменения, то в зависимости от особенностей системы процессу PR1 либо сообщалось о невозможности открытия файла, либо он блокировался до тех пор, пока в процессе PR2 не выполнялась операция закрытия файла. При подобном способе организации одновременная работа нескольких пользователей, связанная с модификацией данных в файле, либо вообще не реализовывалась, либо была очень медленной.</p>
<p>Эти недостатки послужили тем толчком, который заставил разработчиков информационных систем предложить новый подход к управлению информацией. Этот подход был реализован в рамках новых программных систем, названных впоследствии Системами Управления Базами Данных (СУБД), а сами хранилища информации, которые работали под управлением данных систем, назывались базами или банками данных.</p>
<h3 id="-">Этапы развития баз данных</h3>
<h4 id="-">Первый этап развития БД – базы данных на больших ЭВМ</h4>
<p>История развития СУБД насчитывает более 30 лет.</p>
<p>В 1968 году была введена в эксплуатацию первая промышленная СУБД IMS фирмы IBM.</p>
<p>В 1975 году появился первый стандарт ассоциации по языкам систем обработки данных – Conference of Data System Languages (CODASYL), который определил ряд фундаментальных понятий в теории систем баз данных, которые и до сих пор являются основополагающими для сетевой модели данных.</p>
<p>В дальнейшее развитие теории баз данных большой вклад был сделан американским математиком Э.Ф. Коддом, который является создателем реляционной модели данных.</p>
<p>Развитие персональных ЭВМ и появление мощных рабочих станций и сетей ЭВМ повлияло также и на развитие технологии баз данных.</p>
<p>Можно выделить четыре этапа в развитии данного направления в обработке данных. Однако необходимо заметить, что всё же нет жёстких временных ограничений в этих этапах: они плавно переходят один в другой и даже сосуществуют параллельно, но тем не менее выделение этих этапов позволит более чётко охарактеризовать отдельные стадии развития технологии баз данных, подчеркнуть особенности, специфичные для конкретного этапа.</p>
<p>Первый этап развития СУБД связан с организацией баз данных на больших машинах типа IBM 360/370, ЕС-ЭВМ и мини-ЭВМ типа PDP11 (фирмы Digital Equipment Corporation – DEC), разных моделях HP (фирмы Hewlett Packard).</p>
<p>Базы данных хранились во внешней памяти центральной ЭВМ, пользователями этих баз данных были задачи, запускаемые в основном в пакетном режиме. Интерактивный режим доступа обеспечивался с помощью консольных терминалов, которые не обладали собственными вычислительными ресурсами (процессором, внешней памятью) и служили только устройствами ввода-вывода для центральной ЭВМ.</p>
<p>Мощные операционные системы обеспечивали возможность условно параллельного выполнения всего множества задач. Эти системы можно было отнести к системам распределённого доступа, потому что база данных была централизованной, хранилась на устройствах внешней памяти одной центральной ЭВМ, а доступ к ней поддерживался от многих пользователей-задач.</p>
<p>Особенности этого этапа развития выражаются в следующем:</p>
<ul>
<li>все СУБД базируются на мощных мультипрограммных операционных системах (MVS, SVM, RTE, OSRV, RSX, UNIX), поэтому в основном поддерживается работа с централизованной базой данных в режиме распределённого доступа;</li>
<li>функции управления распределением ресурсов в основном осуществляются операционной системой;</li>
<li>поддерживаются языки низкого уровня манипулирования данными, ориентированные на навигационные методы доступа к данным;</li>
<li>значительная роль отводится администрированию данных;</li>
<li>проводятся серьёзные работы по обоснованию и формализации реляционной модели данных;</li>
<li>проводятся теоретические работы по оптимизации запросов и управлению распределённым доступом к централизованной БД, было введено понятие транзакции;</li>
<li>появляются первые языки высокого уровня для работы с реляционной моделью данных, однако отсутствуют стандарты для этих первых языков.</li>
</ul>
<h4 id="-">Второй этап – «эпоха персональных компьютеров»</h4>
<p>На этом этапе появилось множество программ, предназначенных для работы неподготовленных пользователей. Простыми и понятными стали операции копирования файлов и перенос информации с одного компьютера на другой. Появились программы, которые назывались системами управления базами данных и позволяли хранить значительные объёмы информации, они имели удобный интерфейс для заполнения данных и встроенные средства для генерации различных отчётов. Эти программы позволяли автоматизировать многие учётные функции, которые раньше велись вручную.</p>
<p>Компьютеры стали инструментом для ведения документации и собственных учётных функций организациями и отдельными пользователями. Спрос на развитые удобные программы обработки данных заставлял поставщиков программного обеспечения поставлять всё новые системы, которые принято называть настольными (desktop) СУБД.</p>
<p>Значительная конкуренция среди поставщиков заставляла совершенствовать эти системы, предлагая новые возможности, улучшая интерфейс и быстродействие систем, снижая их стоимость.</p>
<p>Наличие на рынке большого числа СУБД, выполняющих сходные функции, потребовало разработки методов экспорта-импорта данных для этих систем и открытия форматов хранения данных.</p>
<p>Особенности этого этапа таковы:</p>
<ul>
<li>все СУБД были рассчитаны на создание БД в основном с монопольным доступом (т.к. компьютер – персональный и не подсоединён к сети);</li>
<li>в редких случаях предполагалась последовательная работа нескольких пользователей, например, сначала оператор, который вводил бухгалтерские документы, а потом главбух, который определял проводки, соответствующие первичным документам;</li>
<li>большинство СУБД имели развитый и удобный пользовательский интерфейс;</li>
<li>большинство СУБД предлагали развитый и удобный инструментарий для разработки готовых приложений без программирования;</li>
<li>инструментальная среда состояла из готовых элементов приложения в виде шаблонов экранных форм, отчётов, графических конструкторов запросов, которые достаточно просто могли быть собраны в единый комплекс;</li>
<li>во всех настольных СУБД поддерживался только внешний уровень представления реляционной модели, то есть только внешний табличный вид структур данных;</li>
<li>при наличии высокоуровневых языков манипулирования данными типа реляционной алгебры и SQL в настольных СУБД поддерживались низкоуровневые языки манипулирования данными на уровне отдельных строк таблиц;</li>
<li>в настольных СУБД отсутствовали средства поддержки ссылочной и структурной целостности базы данных, эти функции должны были выполнять приложения;</li>
<li>наличие монопольного режима работы фактически привело к вырождению функций администрирования БД и в связи с этим – к отсутствию инструментальных средств администрирования БД;</li>
<li>требования к аппаратному обеспечению со стороны настольных СУБД были сравнительно скромными.</li>
</ul>
<p>Яркие представители этого семейства – очень широко использовавшиеся до недавнего времени СУБД Dbase (DbaseIII+, DbaseIV), FoxPro, Clipper, Paradox, MS Access.</p>
<h4 id="-">Третий этап – распределённые базы данных</h4>
<p>После процесса «персонализации» начался обратный процесс – интеграция.</p>
<p>С развитием компьютерных сетей остро встала задача согласованности данных, логически связанных друг с другом, но хранящихся и обрабатывающихся в разных местах. Возникли задачи, связанные с параллельной обработкой транзакций – последовательностей операций над БД, переводящих её из одного непротиворечивого состояния в другое непротиворечивое состояние. Успешное решение этих задач приводит к появлению распределённых баз данных, сохраняющих все преимущества настольных СУБД и в то же время позволяющих организовать параллельную обработку информации и поддержку целостности БД.</p>
<p>Особенности данного этапа:</p>
<ul>
<li>практически все современные СУБД обеспечивают поддержку полной реляционной модели;</li>
<li>большинство современных СУБД рассчитаны на многоплатформенную архитектуру, то есть они могут работать на компьютерах с разной архитектурой и под разными операционными системами, при этом для пользователей доступ к данным, управляемым СУБД на разных платформах, практически неразличим;</li>
<li>необходимость поддержки многопользовательской работы с базой данных и возможность децентрализованного хранения данных потребовали развития средств администрирования БД с реализацией общей концепции средств защиты данных;</li>
<li>потребность в реализации новых СУБД вызвала создание серьёзных теоретических трудов по оптимизации распределённых БД и работе с распределёнными транзакциями и запросами;</li>
<li>чтобы не потерять клиентов, которые ранее работали на настольных СУБД, практически все современные СУБД имеют средства подключения клиентских приложений, разработанных с использованием настольных СУБД, и средства экспорта данных из форматов настольных СУБД второго этапа развития;</li>
<li>именно к этому этапу можно отнести разработку ряда стандартов в рамках языков описания и манипулирования данными начиная с SQL89, SQL92, SQL99 (и т.д.) и технологий по обмену данными между различными СУБД, к которым можно отнести и протокол ODBC (Open DataBase Connectivity), предложенный фирмой Microsoft;</li>
<li>именно к этому этапу можно отнести начало работ, связанных с концепцией объектно-ориентированных БД – ООБД.</li>
</ul>
<p>Первыми представителями СУБД, относящимся к этому этапу, можно считать Oracle7.3, Oracle 8.4 MS SQL6.5, MS SQL7.0, System 10, System 11, Informix, DB2, SQL Base и т.п.</p>
<h4 id="-">Четвёртый этап – дальнейшее развитие</h4>
<p>Этот этап характеризуется появлением новой технологии доступа к данным – «интернет/интранет-доступ». Основное отличие этого подхода от технологии клиент-сервер состоит в том, что отпадает необходимость использования специализированного клиентского программного обеспечения. Для работы с удалённой БД используется стандартный веб-браузер.</p>
<p>При этом код, написанный обычно на языках программирования (Java, PHP, Perl, C#) отслеживает все действия пользователя и транслирует их в низкоуровневые SQL-запросы к базе данных, выполняя, таким образом, ту работу, которой в технологии клиент-сервер занимается клиентская программа.</p>
<p>Удобство данного подхода привело к тому, что он стал использоваться не только для удалённого доступа к базам данных, но и для пользователей локальной сети предприятия, т.к. для подключения нового пользователя не требуется установка дополнительного клиентского программного обеспечения.</p>
<p>У каждого из вышеперечисленных подходов к работе с данными есть свои достоинства и свои недостатки, которые и определяют область применения того или иного метода, и в настоящее время все подходы широко используются.</p>
<h2 id="-">Краткие теоретические сведения</h2>
<p><em>Данные</em> - это представление фактов и идей в формализованном виде, пригодном для передачи и обработки в некотором информационном процессе.</p>
<p><em>База Данных</em> (БД, database) - структурированный организованный набор данных, описывающих характеристики какой-либо физической или виртуальной системы. «Базой данных» часто упрощённо или ошибочно называют Системы Управления Базами Данных (СУБД, database management system, DBMS). Нужно различать набор данных (собственно БД) и программное обеспечение, предназначенное для организации и ведения баз данных (СУБД).</p>
<p>Организация структуры БД формируется, исходя из следующих соображений:</p>
<ol>
<li>Адекватность описываемому объекту или системе - на уровне концептуальной и логической модели.</li>
<li>Удобство использования для ведения учёта и анализа данных - на уровне так называемой физической модели.</li>
</ol>
<p>Виды концептуальных (инфологических) моделей БД:</p>
<ul>
<li>«сущность-связь» (англ. entity-relation, ER);</li>
<li>семантические модели;</li>
<li>графовые модели.</li>
</ul>
<p>Виды логических (даталогических) моделей БД:</p>
<ul>
<li>документальные (архивы) - ориентированные на формат документа, дескрипторные, тезаурусные;</li>
<li>фактографические (картотеки);</li>
<li>теоретико-графовые: иерархическая модель, сетевая модель;</li>
<li>теоретико-множественные: реляционная модель (ER-модель), многомерная модель;</li>
<li>объектно-ориентированные: объектная модель;</li>
<li>основанные на инвертированных файлах (инвертированные файлы содержат: словарь, содержащий все термы, встретившиеся в коллекции и ссылку на массив данных «пост-листа» для каждого из них; «пост-листы», представляющие собой массив информации обо всех вхождениях данного слова в документы коллекции).</li>
</ul>
<p>Модель «сущность-связь» основывается на некой важной семантической информации о реальном мире и предназначена для логического представления данных. Она определяет значения данных в контексте их взаимосвязи с другими данными. Важным для нас является тот факт, что из модели «сущность-связь» могут быть порождены все существующие модели данных (иерархическая, сетевая, реляционная, объектная), поэтому она является наиболее общей. Модель «сущность-связь» была предложена в 1976 г. Питером Пин-Шэн Ченом. </p>
<p>Любая развитая семантическая модель данных, как и реляционная модель, включает структурную, манипуляционную и целостную части, главным назначением семантических моделей является обеспечение возможности выражения семантики данных. Чаще всего на практике семантическое моделирование используется на первой стадии проектирования базы данных. При этом в терминах семантической модели производится концептуальная схема базы данных, которая затем вручную преобразуется к реляционной (или какой-либо другой) схеме.</p>
<p>Основным достоинством данного подхода является отсутствие потребности в дополнительных программных средствах, поддерживающих семантическое моделирование. Требуется только знание основ выбранной семантической модели и правил преобразования концептуальной схемы в реляционную схему.</p>
<p>Графовые модели данных отражают совокупность объектов реального мира в виде графа взаимосвязанных информационных объектов. В зависимости от типа графа выделяют иерархическую или сетевую модели. Исторически эти модели появились раньше, и в настоящий момент они используются реже, чем более современная реляционная модель данных.</p>
<h3 id="-">Многоуровневая архитектура баз данных, понятие физического и логического уровней баз данных</h3>
<p>Проектирование БД начинается с этапа «концептуального проектирования».</p>
<p>Концептуальное проектирование - это сбор, анализ и редактирование требований к данным. Для этого осуществляются следующие мероприятия:</p>
<ul>
<li>обследование предметной области, изучение её информационной структуры;</li>
<li>выявление всех фрагментов предметной области, каждый из которых характеризуется представлением, информационными объектами и связями между ними, процессами над информационными объектами;</li>
<li>моделирование и интеграция всех представлений.</li>
</ul>
<p>По окончании этапа концептуального проектирования мы получаем «концептуальную модель», инвариантную (нечувствительную) к структуре базы данных. Эта модель будет нас интересовать на «инфологическом уровне» схемы, представленной на следующем рисунке. Часто такая модель представляется в виде модели «сущность-связь».</p>
<p>Следующий этап - логическое проектирование.
Логическое проектирование - преобразование требований к данным в структуры данных. На выходе этого этапа мы получаем СУБД-ориентированную структуру базы данных и спецификации прикладных программ. На этом этапе часто моделируют базы данных применительно к различным СУБД и проводят сравнительный анализ моделей. Эта модель будет нас интересовать на «даталогическом уровне» схемы, представленной на следующем рисунке.</p>
<p>Следующий этап - физическое проектирование.
Физическое проектирование - определение особенности хранения данных, методов доступа и т.д. На выходе этого этапа мы получаем «физическую модель» базы данных. Эта модель будет нас интересовать на «физическом уровне» схемы, представленной на следующем рисунке.</p>
<p><img src="file:///home/dima/Desktop/lab2_bd/%D0%AD%D0%A3%D0%9C%D0%9A%D0%94_%D0%91%D0%94_1/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F/content/index_files/image022.jpg" alt="Рис. 1 Схема уровней БД"></p>
<p><em>Рисунок. 1 Схема уровней БД</em></p>
<p>Различие уровней представления проще понять из того, кем они реализуется и что на них реализуется:</p>
<p>концептуальный (инфологический) уровень</p>
<ul>
<li>реализуется аналитиком (используется инфологическая модель «сущность-связь»);</li>
<li>формируются сущности;</li>
<li>формируются атрибуты;</li>
<li>формируются связи.</li>
</ul>
<p>логический (даталогический) уровень</p>
<ul>
<li>реализуется программистом;</li>
<li>определяются записи;</li>
<li>определяются элементы и типы данных;</li>
<li>определяются способы организации связей между записями.</li>
</ul>
<p>физический уровень</p>
<ul>
<li>реализуется администратором;</li>
<li>определяется группирование данных;</li>
<li>определяются индексы;</li>
<li>определяются методы доступа.</li>
</ul>
<h1 id="-">Разработка БД</h1>
<h2 id="er-">ER-модель</h2>
<p><img src="dev/er.png" alt="Рис. 2 ER-модель базы данных"></p>
<p>На рисунке 2 представлена ER-модель базы данных приложения. Рассмотрим ее сущности подробнее.</p>
<p>В базе данных нам необходимо хранить информацию о заведениях, пользователях и заказах. Получаем следующие модели:</p>
<p><em>Пользователь</em></p>
<ol>
<li>Email</li>
<li>Телефон</li>
<li>Имя</li>
<li>Пароль</li>
</ol>
<p><em>Заведение</em></p>
<ol>
<li>Имя</li>
<li>Описание</li>
<li>Адрес</li>
<li>Фото</li>
<li>Владелец</li>
<li>Категория</li>
<li>Город</li>
<li>Веб-страница</li>
<li>Станция метро</li>
<li>Email</li>
</ol>
<p><em>Категория</em></p>
<ol>
<li>Название категории</li>
</ol>
<p><em>Заказ</em></p>
<ol>
<li>Столик</li>
<li>Пользователь</li>
<li>Время</li>
<li>Код подтверждения</li>
<li>Комментарий</li>
</ol>
<p><em>Столик</em></p>
<ol>
<li>Заведение</li>
<li>Количество мест</li>
</ol>
<p>Владелец заведения может публиковать новости, а пользователи могут на них подписываться:</p>
<p><em>Новости</em></p>
<ol>
<li>Заголовок</li>
<li>Контент</li>
<li>Время публикации</li>
<li>Заведение</li>
</ol>
<p><em>Подписка</em></p>
<ol>
<li>Пользователь</li>
<li>Заведение</li>
</ol>
<p>Также пользователи могут оставлять комментарии к заведению и оценивать его по нескольким параметрам (например, кухня, сервис или атмосфера):</p>
<p><em>Комментарий</em></p>
<ol>
<li>Содержание</li>
<li>Пользователь</li>
<li>Заведение</li>
<li>Время создания</li>
</ol>
<p><em>Рейтинг</em></p>
<ol>
<li>Тип</li>
<li>Заведение</li>
<li>Пользователь</li>
<li>Баллы</li>
</ol>
<p><em>Тип рейтинга</em></p>
<ol>
<li>Название</li>
</ol>
<h2 id="-">Выбор СУБД</h2>
<p>Проект выдвигает следующие требования к СУБД:</p>
<ul>
<li>Мультиплатформенность</li>
<li>Невысокие системные требования</li>
<li>Свободная лицензия</li>
<li>Существующая интеграция с ORM Active Record фреймворка Rails</li>
<li>Поддержка облчной платформой Heroku.
Сравним три популярнейших СУБД в экосистеме Rails: MySQL, PostgreSQL и SQLite</li>
</ul>
<p>Общие сведения</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>PostreSQL</th>
<th>SQLite</th>
</tr>
</thead>
<tbody>
<tr>
<td>Разработчик</td>
<td>Oracle Corporation</td>
<td>PostgreSQL Global Development Group</td>
<td>Ричард Хипп</td>
</tr>
<tr>
<td>Дата выпуска первой версии</td>
<td>1995-11</td>
<td>1989-06</td>
<td>2000-08-17</td>
</tr>
<tr>
<td>Последняя стабильная версия</td>
<td>5.6.2</td>
<td>9.3.4</td>
<td>3.8.0.2</td>
</tr>
<tr>
<td>Дата посленего релиза</td>
<td>2014-09</td>
<td>2014-03-20</td>
<td>2013-09-03</td>
</tr>
<tr>
<td>Лицензия</td>
<td>GPL v2 или Проприетарная</td>
<td>PostgreSQL License</td>
<td>Public domain</td>
</tr>
<tr>
<td>Поддерживаемые ОС</td>
<td>Windows, Linux, OS X, BSD</td>
<td>Windows, Linux, OS X, BSD</td>
<td>Windows, Linux, OS X, BSD</td>
</tr>
<tr>
<td>Выполнение ACID-принципов</td>
<td>Да</td>
<td>Да</td>
<td>Да</td>
</tr>
<tr>
<td>Ссылочная целостность</td>
<td>Частично</td>
<td>Да</td>
<td>Да</td>
</tr>
<tr>
<td>Транзакции</td>
<td>Кроме DDL</td>
<td>Да</td>
<td>Да</td>
</tr>
<tr>
<td>Поддержка Юникода</td>
<td>Кроме регулярных выражений</td>
<td>Да</td>
<td>Да</td>
</tr>
</tbody>
</table>
<p>Пределы хранимых данных</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>PostreSQL</th>
<th>SQLite</th>
</tr>
</thead>
<tbody>
<tr>
<td>Размер БД</td>
<td>Неограничен</td>
<td>Неограничен</td>
<td>128 ТБ</td>
</tr>
<tr>
<td>Размер таблицы</td>
<td>64 ТБ</td>
<td>32 ТБ</td>
<td>Ограничен размером файла</td>
</tr>
<tr>
<td>Размер строки</td>
<td>64 КБ</td>
<td>1.6 ТБ</td>
<td>Ограничен размером файла</td>
</tr>
<tr>
<td>Количество столбцов на одну строку</td>
<td>4096</td>
<td>250-1600 в зависимости от типа данных</td>
<td>32767</td>
</tr>
<tr>
<td>Размер Blob/Clob данных</td>
<td>4 ГБ (longtext, longblob)</td>
<td>4 ТБ</td>
<td>2 ГБ</td>
</tr>
<tr>
<td>Размер CHAR данных</td>
<td>64 КБ (text)</td>
<td>1 ГБ</td>
<td>2 ГБ</td>
</tr>
<tr>
<td>Размер NUMBER данных</td>
<td>64 бита</td>
<td>Неограничен</td>
<td>64 бита</td>
</tr>
</tbody>
</table>
<h3 id="mysql">MySQL</h3>
<p>MySQL — свободная реляционная система управления базами данных. Разработку и поддержку MySQL осуществляет корпорация Oracle, получившая права на торговую марку вместе с поглощённой Sun Microsystems, которая ранее приобрела шведскую компанию MySQL AB. Продукт распространяется как под GNU General Public License, так и под собственной коммерческой лицензией. Помимо этого, разработчики создают функциональность по заказу лицензионных пользователей. Именно благодаря такому заказу почти в самых ранних версиях появился механизм репликации.</p>
<p>MySQL является решением для малых и средних приложений. Входит в состав серверов WAMP, AppServ, LAMP и в портативные сборки серверов Денвер, XAMPP, VertrigoServ. Обычно MySQL используется в качестве сервера, к которому обращаются локальные или удалённые клиенты, однако в дистрибутив входит библиотека внутреннего сервера, позволяющая включать MySQL в автономные программы.</p>
<p>Гибкость СУБД MySQL обеспечивается поддержкой большого количества типов таблиц: пользователи могут выбрать как таблицы типа MyISAM, поддерживающие полнотекстовый поиск, так и таблицы InnoDB, поддерживающие транзакции на уровне отдельных записей. Более того, СУБД MySQL поставляется со специальным типом таблиц EXAMPLE, демонстрирующим принципы создания новых типов таблиц. Благодаря открытой архитектуре и GPL-лицензированию, в СУБД MySQL постоянно появляются новые типы таблиц.</p>
<h3 id="postresql">PostreSQL</h3>
<p>PostgreSQL (произносится «Пост-Грес-Кью-Эль») — свободная объектно-реляционная система управления базами данных.</p>
<p>На сегодняшний день выпущена версия PostgreSQL v9, которая является значительным событием в мире баз данных, так как количество новых возможностей добавленных в этой версии, позволяет говорить о возникновении интереса крупного бизнеса как в использовании, так и его продвижении. Так, крупнейшая компания в мире, Fujitsu поддержала работы над версией 9, выпустила коммерческий модуль Extended Storage Management. Либеральная BSD-лицензия позволяет коммерческим компаниям выпускать свои версии PostgreSQL под своим именем и осуществлять коммерческую поддержку. Например, компания Pervasive объявила о выпуске Pervasive Postgres.</p>
<p>PostgreSQL поддерживается на всех современных Unix системах (34 платформы), включая наиболее распространенные, такие как Linux, FreeBSD, NetBSD, OpenBSD, SunOS, Solaris, DUX, а также под Mac OS X. Начиная с версии 8.X PostgreSQL работает в &quot;native&quot; режиме под MS Windows. Известно, что есть успешные попытки работать с PostgreSQL под Novell Netware 6 и OS/2.</p>
<p>PostgreSQL используется как полигон для исследований нового типа баз данных, ориентированных на работу с потоками данных - это проект TelegraphCQ, стартовавший в 2002 году в Беркли после успешного проекта Telegraph (название главной улицы в Беркли). Интересно, что компания Streambase, которая была основана Майком Стоунбрейкером в 2003 году (изначально &quot;Grassy Brook&quot;) для коммерческого продвижения этого нового поколения баз данных, никаким образом не ассоциируется с проектом Беркли.</p>
<h3 id="sqlite">SQLite</h3>
<p>SQLite — компактная встраиваемая реляционная база данных. Исходный код библиотеки передан в общественное достояние. В 2005 году проект получил награду Google-O’Reilly Open Source Awards.</p>
<p>Слово «встраиваемый» означает, что SQLite не использует парадигму клиент-сервер, то есть движок SQLite не является отдельно работающим процессом, с которым взаимодействует программа, а предоставляет библиотеку, с которой программа компонуется и движок становится составной частью программы. Таким образом, в качестве протокола обмена используются вызовы функций (API) библиотеки SQLite. Такой подход уменьшает накладные расходы, время отклика и упрощает программу. SQLite хранит всю базу данных (включая определения, таблицы, индексы и данные) в единственном стандартном файле на том компьютере, на котором исполняется программа. Простота реализации достигается за счёт того, что перед началом исполнения транзакции записи весь файл, хранящий базу данных, блокируется; ACID-функции достигаются в том числе за счёт создания файла журнала.</p>
<p>Сама библиотека SQLite написана на C; существует большое количество привязок к другим языкам программирования, в том числе Delphi, C++, Java, C#, VB.NET, Python, Perl, PHP, PureBasic[4], Tcl (средства для работы с Tcl включены в комплект поставки SQLite), Ruby, Haskell, Scheme, Smalltalk, Lua и Parser, а также ко многим другим.</p>
<p>Простота и удобство встраивания SQLite привели к тому, что библиотека используется в браузерах, музыкальных плеерах и многих других программах.</p>
<p>В частности, SQLite используют:</p>
<ul>
<li>Adobe Integrated Runtime — среда для запуска приложений (частично);</li>
<li>Gears;</li>
<li>Autoit;</li>
<li>Фреймворк Qt;</li>
<li>Платформа XUL на движке Gecko 1.9+, XULRunner 1.9+ и, потенциально, все приложения, основанные на этой платформе, в том числе Mozilla Firefox (начиная с версии 3.0)</li>
<li>Songbird</li>
<li>Skype[7];</li>
<li>Некоторые модели GPS-навигаторов Garmin</li>
<li>Android API</li>
</ul>
<p>В качестве СУБД была выбрана PostgreSQL по следующим причинам:</p>
<ul>
<li>PostgreSQL является бесплатной СУБД.</li>
<li>Отличная интеграция с языком высокого уровня Ruby.</li>
<li>Как следствие предыдущего пункта, PostgreSQL – идеальное решение для реализации web-приложений, написанных на Ruby.</li>
<li>Поддержка БД практически неограниченного размера.</li>
<li>Мощные и надёжные механизмы транзакций и репликации (механизм синхронизации содержимого нескольких копий объекта (например, содержимого базы данных). Репликация — это процесс, под которым понимается копирование данных из одного источника на множество других и наоборот).</li>
<li>Бесплатная поддержка облачной платформой Heroku.</li>
<li>Наследование.</li>
<li>Легкая расширяемость.</li>
</ul>
<h2 id="-">Физический уровень модели данных</h2>
<p>Модель данных на физическом уровне отличается от модели данных на логическом уровне тем, что она полностью ориентирована на выбранную СУБД, т.е. в отличие от логической модели, в которой не имеет значения, какой конкретно тип данных имеет атрибут, в физической модели данных важно описать информацию о конкретных физических объектах - таблицах, полях, индексах, процедурах и т.д.</p>
<p>Соответствия между объектами логического и физического уровня показаны в следующих таблицах:</p>
<p>Модели пользователей соответствует таблица users</p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Email</td>
<td>email</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Имя</td>
<td>name</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Пароль</td>
<td>id</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели заведения соответствует таблица clubs</p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Email</td>
<td>email</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Имя</td>
<td>name</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Описание</td>
<td>description</td>
<td>text</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Адрес</td>
<td>address</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Фото</td>
<td>photo</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Веб-старница</td>
<td>site</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Станция метро</td>
<td>metro</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Владелец</td>
<td>owner_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Город</td>
<td>city</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Категория</td>
<td>category_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
</tbody>
</table>
<p>Модели категории соответствует таблица categories</p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Название</td>
<td>name</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели заказа соответствует таблица orders</p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Столик</td>
<td>table_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Пользователь</td>
<td>user_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Время</td>
<td>time time</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Код подтверждения</td>
<td>confirmation</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Комметарий</td>
<td>comment</td>
<td>text</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели столика соответствует таблица tables</p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Заведение</td>
<td>club_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Количество мест</td>
<td>seats</td>
<td>integer</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели новости соответствует таблица news </p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Заведение</td>
<td>club_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Заголовок</td>
<td>title</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Контент</td>
<td>content</td>
<td>text</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Время публикации</td>
<td>created_at</td>
<td>time</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели подписки соответствует таблица subscribes</p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Заведение</td>
<td>club_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Пользователь</td>
<td>user_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
</tbody>
</table>
<p>Модели комментария соответствует таблица comments </p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Заведение</td>
<td>club_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Пользователь</td>
<td>user_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Содержание</td>
<td>content</td>
<td>text</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Время создания</td>
<td>created_at</td>
<td>time</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели рейтинга соответствует таблица rates </p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Заведение</td>
<td>club_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Пользователь</td>
<td>user_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Тип рейтинга</td>
<td>rating_type_id</td>
<td>text</td>
<td>Нет</td>
<td>Да</td>
</tr>
<tr>
<td>Баллы</td>
<td>stars</td>
<td>integer</td>
<td>Нет</td>
<td>Нет</td>
</tr>
</tbody>
</table>
<p>Модели типа рейтинга соответствует таблица rating_types </p>
<table>
<thead>
<tr>
<th>Атрибут</th>
<th>Название</th>
<th>Тип данных</th>
<th>PK</th>
<th>FK</th>
</tr>
</thead>
<tbody>
<tr>
<td>Номер</td>
<td>id</td>
<td>integer</td>
<td>Да</td>
<td>Нет</td>
</tr>
<tr>
<td>Название</td>
<td>name</td>
<td>varchar(255)</td>
<td>Нет</td>
<td>Нет</td>
</tr>
<tr>
<td>Пользователь</td>
<td>user_id</td>
<td>integer</td>
<td>Нет</td>
<td>Да</td>
</tr>
</tbody>
</table>
<h2 id="-">Реализация</h2>
<h3 id="active-record">Active Record</h3>
<p>В Ruby on Rails приложениях для быстрой разработки базы данных используется Active Record.</p>
<h3 id="active-record-">Active Record как паттерн</h3>
<p>Active Record это M в MVC – модель, которая является слоем в системе, ответственным за представление бизнес-логики и данных. Active Record упрощает создание и использование бизнес-объектов, данные которых требуют постоянного хранения в базе данных. Сама по себе эта реализация паттерна Active Record является описанием системы ORM (Object Relational Mapping).
Active Record был описан Martin Fowler в его книге Patterns of Enterprise Application Architecture. В Active Record объекты содержат и сохраненные данные, и поведение, которое работает с этими данными. Active Record исходит из мнения, что обеспечение логики доступа к данным как части объекта покажет пользователям этого объекта то, как читать и писать в базу данных.</p>
<h3 id="active-record-orm">Active Record – это фреймворк ORM</h3>
<p>Active Record предоставляет нам несколько механизмов, наиболее важными являются:</p>
<ul>
<li>Представления моделей и их данных.</li>
<li>Представления связей между этими моделями.</li>
<li>Представления иерархий наследования с помощью связанных моделей.</li>
<li>Валидации моделей до того, как они будут сохранены в базу данных.</li>
<li>Выполнения операций с базой данных в объктно-ориентированном стиле</li>
</ul>
<h3 id="-">Генерирование временной платформы</h3>
<p>Нам нужно создать таблицу базы данных и модель Rails, которая позволит нашему приложению использовать эту таблицу. Все это можно сделать с помощью одной команды, попросив Rails сгенерировать то, что называется временной платформой – scaffold (англ. строительные леса) для заданной модели. Отметим, что слово в командной строке используется в форме единственного числа — Club. В Rails модель автоматически отображается на таблицу базы данных, чье имя является формой множественного числа класса модели. В нашем случае мы запросили модель под названием Club, поэтому Rails связывает ее с таблицей по имени clubs.</p>
<pre><code>SmartReserve&gt; rails generate scaffold Club name:string description:text 
address:string photo:string city:string web_site:tring metro:string email:string
      invoke  active_record
      create    db/migrate/20140510103446_create_clubs.rb
      create    app/models/club.rb
      invoke    test_unit
      create      test/models/club_test.rb
      create      test/fixtures/clubs.yml
      invoke  resource_route
       route    resources :clubs
      invoke  scaffold_controller
      create    app/controllers/clubs_controller.rb
      invoke    erb
      create      app/views/clubs
      create      app/views/clubs/index.html.erb
      create      app/views/clubs/edit.html.erb
      create      app/views/clubs/show.html.erb
      create      app/views/clubs/new.html.erb
      create      app/views/clubs/_form.html.erb
      invoke    test_unit
      create      test/controllers/clubs_controller_test.rb
      invoke    helper
      create      app/helpers/clubs_helper.rb
      invoke      test_unit
      create        test/helpers/clubs_helper_test.rb
      invoke    jbuilder
      create      app/views/clubs/index.json.jbuilder
      create      app/views/clubs/show.json.jbuilder
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/clubs.js.coffee
      invoke    scss
      create      app/assets/stylesheets/clubs.css.scss
      invoke  scss
      create    app/assets/stylesheets/scaffolds.css.scss
</code></pre><p>Генератор создал целый пакет файлов. Нас в первую очередь интересует файл миграции 20140510103446_create_clubs.rb</p>
<pre><code>class CreateClubs &lt; ActiveRecord::Migration
  def change
    create_table :clubs do |t|
      t.string :name
      t.text :description
      t.string :photo
      t.city :string
      t.string :web_site
      t.string :metro
      t.string :email
      t.string :avatar_url

      t.timestamps
    end
  end
end
</code></pre><p>Добавим ссылку на владельца</p>
<pre><code>class CreateClubs &lt; ActiveRecord::Migration
  def change
    create_table :clubs do |t|
      t.string :name
      t.text :description
      t.string :photo
      t.city :string
      t.string :web_site
      t.string :metro
      t.string :email
      t.string :avatar_url

      t.timestamps
    end
  end

  add_reference :clubs, :owner, index: true
end
</code></pre><p>В файле миграции записаны изменения, которые нужно провести с базой данных. Для приминения миграции используем команду rake:</p>
<pre><code>SmartReserve&gt; rake db:migrate
== 20140510103446 CreateClubs: migrating ======================================
-- create_table(:clubs)
   -&gt; 0.0039s
== 20140510103446 CreateClubs: migrated (0.0044s) =============================
</code></pre><p>Остальные сущности добавим таким же образом (см. Приложение 1)
Сгененррированный при этом SQL-код содержится в файле db/structure.sql</p>
<p>Добавим тестовые данные в нашу базу. Создание таких данные можно описать средствами ORM в файле db/seeds.rb и загрузить командой rake db:seed. Например</p>
<pre><code># метод create создает в базе данных записи в соответствии с переданными параметрами
City.create([
  { name: &#39;Chicago&#39; }, # создадим запись для города с параметром name “Chicago”
  { name: &#39;Copenhagen&#39; } # и “Copenhagen”, соответвенно
])
</code></pre><p>Содержание файла db/seeds.rb</p>
<pre><code>#encoding: utf-8 

# создадим несколько пользователей 
User.create([ 
  {name: &#39;Alex&#39;, email: &#39;alex@alivance.com&#39;, password: &#39;123456&#39;}, 
  {name: &#39;Bob&#39;, email: &#39;bob@alivance.com&#39;, password: &#39;Qwerty12&#39;}, 
  {name: &#39;Alice&#39;, email: &#39;alice@alivance.com&#39;, password: &#39;EbMNk44&#39;}, 
  {name: &#39;Eve&#39;, email: &#39;eve@alivance.com&#39;, password: &#39;![dwMk]}654iEydbPcdd#&#39;}, 
]) 

# выполним запрос к базе 
# теперь в переменной alex объект с полями, соответствующими записи в таблице 
alex = User.where(name: &#39;Alex&#39;).first 
bob = User.where(name: &#39;Bob&#39;).first 
alice = User.where(name: &#39;Alice&#39;).first 

# две категории 
Category.create([ 
  {name: &quot;Бар&quot;}, 
  {name: &quot;Кафе&quot;} 
]) 

cafe = Category.where(name: &quot;Кафе&quot;).first 

# два типа рейтинга 
RatingType.create([ 
  {name: &quot;Сервис&quot;}, 
  {name: &quot;Кухня&quot;} 
]) 

kitchen = RatingType.where(name: &quot;Кухня&quot;).first 

# создадим сотню заведений 
# такие громоздкие операции лучше выполнять в одной транзакции 
Club.transaction do 
  100.times do |i| 
    # в переменной c будет объект, соответствующий только что созданной записи 
    c = Club.create({ 
      name: &quot;Club#{i}&quot;, 
      description: &quot;Описание&quot;, 
      address: &quot;ул. Ленина, д. #{i}&quot;, 
      photo: &quot;http://smartreserve.by/assets/img/default-photo.png&quot;, 
      web_site: &quot;http://example.com&quot;, 
      email: &quot;club#{i}@alivance.com&quot;, 
      owner_id: alex.id, # ссылка на владельца 
      category_id: cafe.id # ссылка на категорию 
    }) 

    # по двадцать столиков для каждого заведения 
    20.times do 
      t = Table.create({ 
        club_id: c.id, 
        seats: 5 
      }) 

      # по заказу на каждый столик 
      Order.create({ 
        time: Time.now, 
        confirmation: &quot;1234&quot;, 
        table_id: t.id, 
        user_id: bob.id 
      }) 
    end 

    # по одной новости 
    News.create(title: &quot;Мы открылись&quot;, content: &quot;Мы открылись&quot;, club_id: c.id, created_at: Time.now) 

    # подписке 
    Subscribe.create(club_id: c.id, user_id: alice.id) 

    # оценке 
    Rate.create(club_id: c.id, user_id: alice.id, stars: 5) 

    # и комментарию 
    Comment.create(club_id: c.id, user_id: alice.id, content: &quot;First comment&quot;, created_at: Time.now) 
  end 
end
</code></pre><p>Загрузим данные в базу</p>
<pre><code>SmartReserve&gt; rake db:seed
-- данная команда выводит все SQL-запросы, происходящие во время загрузки данных
-- приведем только самые основные

-- создание пользователей 
(0.3ms)  BEGIN 
  SQL (0.3ms)  INSERT INTO &quot;users&quot; (&quot;email&quot;, &quot;name&quot;, &quot;password&quot;) 
  VALUES ($1, $2, $3) RETURNING &quot;id&quot;   
  [[&quot;email&quot;, &quot;alex@alivance.com&quot;], [&quot;name&quot;, &quot;Alex&quot;], 
   [&quot;password&quot;, &quot;123456&quot;]] 
(58.2ms)  COMMIT 
(0.2ms)  BEGIN 
  SQL (0.3ms)  INSERT INTO &quot;users&quot; (&quot;email&quot;, &quot;name&quot;, &quot;password&quot;) 
  VALUES ($1, $2, $3) RETURNING &quot;id&quot;   
  [[&quot;email&quot;, &quot;bob@alivance.com&quot;], [&quot;name&quot;, &quot;Bob&quot;], 
   [&quot;password&quot;, &quot;Qwerty12&quot;]] 
(62.2ms)  COMMIT 
(0.2ms)  BEGIN 
  SQL (0.2ms)  INSERT INTO &quot;users&quot; (&quot;email&quot;, &quot;name&quot;, &quot;password&quot;) 
  VALUES ($1, $2, $3) RETURNING &quot;id&quot;   
  [[&quot;email&quot;, &quot;alice@alivance.com&quot;], [&quot;name&quot;, &quot;Alice&quot;], 
   [&quot;password&quot;, &quot;EbMNk44&quot;]] 
(19.7ms)  COMMIT 
(0.0ms)  BEGIN 
  SQL (0.6ms)  INSERT INTO &quot;users&quot; (&quot;email&quot;, &quot;name&quot;, &quot;password&quot;) 
  VALUES ($1, $2, $3) RETURNING &quot;id&quot;   
  [[&quot;email&quot;, &quot;eve@alivance.com&quot;], [&quot;name&quot;, &quot;Eve&quot;], 
   [&quot;password&quot;, &quot;![dwMk]}654iEydbPcdd#&quot;]] 
(34.7ms)  COMMIT 

-- выбор пользователей по имени 
User Load (0.7ms)  SELECT  &quot;users&quot;.* FROM &quot;users&quot;   
  WHERE &quot;users&quot;.&quot;name&quot; = &#39;Alex&#39;   
  ORDER BY &quot;users&quot;.&quot;id&quot; ASC LIMIT 1 
User Load (0.3ms)  SELECT  &quot;users&quot;.* FROM &quot;users&quot;   
  WHERE &quot;users&quot;.&quot;name&quot; = &#39;Bob&#39;   
  ORDER BY &quot;users&quot;.&quot;id&quot; ASC LIMIT 1 
User Load (0.2ms)  SELECT  &quot;users&quot;.* FROM &quot;users&quot;   
  WHERE &quot;users&quot;.&quot;name&quot; = &#39;Alice&#39;   
  ORDER BY &quot;users&quot;.&quot;id&quot; ASC LIMIT 1 

-- создание категорий 
(0.1ms)  BEGIN 
  SQL (0.3ms)  INSERT INTO &quot;categories&quot; (&quot;name&quot;) VALUES ($1) 
  RETURNING &quot;id&quot;  [[&quot;name&quot;, &quot;Бар&quot;]] 
(41.7ms)  COMMIT 
(0.1ms)  BEGIN 
  SQL (0.2ms)  INSERT INTO &quot;categories&quot; (&quot;name&quot;) VALUES ($1) 
  RETURNING &quot;id&quot;  [[&quot;name&quot;, &quot;Кафе&quot;]] 
(41.0ms)  COMMIT 

-- выбор категории по имени 
Category Load (1.7ms)  SELECT  &quot;categories&quot;.* FROM &quot;categories&quot; 
  WHERE &quot;categories&quot;.&quot;name&quot; = &#39;Кафе&#39;   
  ORDER BY &quot;categories&quot;.&quot;id&quot; ASC LIMIT 1 

-- создание типов рейтинга 
(0.4ms)  BEGIN 
  SQL (0.4ms)  INSERT INTO &quot;rating_types&quot; (&quot;name&quot;) VALUES ($1) 
  RETURNING &quot;id&quot;  [[&quot;name&quot;, &quot;Сервис&quot;]] 
(51.7ms)  COMMIT 
(0.1ms)  BEGIN 
  SQL (0.9ms)  INSERT INTO &quot;rating_types&quot; (&quot;name&quot;) VALUES ($1) 
  RETURNING &quot;id&quot;  [[&quot;name&quot;, &quot;Кухня&quot;]] 
(64.1ms)  COMMIT 

-- выбор типа рейтинга по имени 
RatingType Load (0.6ms)  SELECT  &quot;rating_types&quot;.* FROM &quot;rating_types&quot; 
  WHERE &quot;rating_types&quot;.&quot;name&quot; = &#39;Кухня&#39; 
  ORDER BY &quot;rating_types&quot;.&quot;id&quot; ASC LIMIT 1 

-- создание заведений в отдельной транзакции 
(0.2ms)  BEGIN 
  SQL (0.4ms)  INSERT INTO &quot;clubs&quot; 
    (&quot;address&quot;, &quot;category_id&quot;, &quot;description&quot;, &quot;email&quot;, &quot;name&quot;, 
     &quot;owner_id&quot;, &quot;photo&quot;, &quot;web_site&quot;) 
     VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING &quot;id&quot; 
     [[&quot;address&quot;, &quot;ул. Ленина, д. 0&quot;], [&quot;category_id&quot;, 2], 
      [&quot;description&quot;, &quot;Описание&quot;], [&quot;email&quot;, &quot;club0@alivance.com&quot;], 
      [&quot;name&quot;, &quot;Club0&quot;], [&quot;owner_id&quot;, 1], 
      [&quot;photo&quot;, &quot;http://smartreserve.by/assets/img/default-photo.png&quot;], 
      [&quot;web_site&quot;, &quot;http://example.com&quot;]] 

  – создание столиков 
  SQL (0.3ms)  INSERT INTO &quot;tables&quot; (&quot;club_id&quot;, &quot;seats&quot;) 
    VALUES ($1, $2) RETURNING &quot;id&quot;   
    [[&quot;club_id&quot;, 1], [&quot;seats&quot;, 5]] 

  – создание заказов   
  SQL (0.3ms)  INSERT INTO &quot;orders&quot; 
    (&quot;confirmation&quot;, &quot;table_id&quot;, &quot;time&quot;, &quot;user_id&quot;) 
    VALUES ($1, $2, $3, $4) RETURNING &quot;id&quot; 
    [[&quot;confirmation&quot;, &quot;1234&quot;], [&quot;table_id&quot;, 1], 
     [&quot;time&quot;, &quot;2014-11-24 03:58:31.167403&quot;], [&quot;user_id&quot;, 2]] 

  – и так далее, для каждого столика и заказа

  – создание новости 
  SQL (0.3ms)  INSERT INTO &quot;news&quot; 
    (&quot;club_id&quot;, &quot;content&quot;, &quot;created_at&quot;, &quot;title&quot;) 
    VALUES ($1, $2, $3, $4) RETURNING &quot;id&quot;   
    [[&quot;club_id&quot;, 127], [&quot;content&quot;, &quot;Мы открылись&quot;], 
     [&quot;created_at&quot;, &quot;2014-11-24 03:58:31.218141&quot;], 
     [&quot;title&quot;, &quot;Мы открылись&quot;]] 

  – создание подписки 
  SQL (0.2ms)  INSERT INTO &quot;subscribes&quot; (&quot;club_id&quot;, &quot;user_id&quot;) 
    VALUES ($1, $2) RETURNING &quot;id&quot; 
    [[&quot;club_id&quot;, 127], [&quot;user_id&quot;, 3]] 

  – создание оценки 
  SQL (0.4ms)  INSERT INTO &quot;rates&quot; (&quot;club_id&quot;, &quot;stars&quot;, &quot;user_id&quot;) 
    VALUES ($1, $2, $3) RETURNING &quot;id&quot;   
    [[&quot;club_id&quot;, 127], [&quot;stars&quot;, 5], [&quot;user_id&quot;, 3]] 

  – создание комментария 
  SQL (0.3ms)  INSERT INTO &quot;comments&quot; 
    (&quot;club_id&quot;, &quot;content&quot;, &quot;created_at&quot;, &quot;user_id&quot;) 
    VALUES ($1, $2, $3, $4) RETURNING &quot;id&quot;   
    [[&quot;club_id&quot;, 127], [&quot;content&quot;, &quot;First comment&quot;], 
     [&quot;created_at&quot;, &quot;2014-11-24 03:58:31.247139&quot;], 
     [&quot;user_id&quot;, 3]] 

  – и так далее, для каждого заведения 

-- конец транзакции 
(1.8ms)  COMMIT
</code></pre><h1 id="-">Заключение</h1>
<p>В ходе выполнения курсовой работы была создана полнофункциональная база данных, полностью готовая к использованию в приложении SmartReserve.
Сайт был создан при помощи популярного фреймворка Ruby on Rails. Для него имеется множество плагинов и готовых решений, что позволяет создать приложения любой сложности. Одной из причин выбора данного фреймворка является возможность увеличения функциональности сайта с помощью плагинов и легкость в создании и изменении функционала.
Поставленные в начале работы цели и задачи были полностью решены при выполнении этой курсовой работы. При выполнении работы были получены знания о реляционных СУБД, практические навыки по разработке баз данных с использованием самых современных технологий.</p>
<h1 id="-">СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ</h1>
<ol>
<li>Sam Ruby, Dave Thomas, David Heinemeier Hansson. Agile Web Development with Rails, 2010. - 472 с. </li>
<li>Armando Fox, David Patterson. Engineering Long-Lasting Software: An Agile Approach Using SaaS and Cloud Computing, 2012. - 355 с. </li>
<li>Wikipedia [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://wikipedia.org/">http://wikipedia.org/</a> </li>
<li>PostgreSQL [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://www.postgresql.org/">http://www.postgresql.org/</a> </li>
<li>Heroku [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://www.heroku.com/">http://www.heroku.com/</a> </li>
<li>Ruby on Rails API [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://api.rubyonrails.org/">http://api.rubyonrails.org/</a> </li>
<li>Ruby on Rails Guides [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://guides.rubyonrails.org/">http://guides.rubyonrails.org/</a> </li>
<li>Ruby-Doc.org [Электронный ресурс]. – Электронные данные. – Режим доступа: .org/&quot;&gt;<a href="http://www.ruby-doc.org/">http://www.ruby-doc.org/</a> </li>
<li>MySQL [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://www.mysql.com/">http://www.mysql.com/</a> </li>
<li>SQLite [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="http://www.sqlite.org/">http://www.sqlite.org/</a> </li>
<li>GitHub [Электронный ресурс]. – Электронные данные. – Режим доступа: <a href="https://github.com/">https://github.com/</a></li>
</ol>
<h1 id="-1">Приложение 1</h1>
<h2 id="sql-rails">SQL код, сгенерированный Rails</h2>
<pre><code>-- MySQL dump 10.13  Distrib 5.5.40, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: db_development
-- ------------------------------------------------------
-- Server version 5.5.40-0ubuntu0.12.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE=&#39;+00:00&#39; */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#39;NO_AUTO_VALUE_ON_ZERO&#39; */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `abouts`
--

DROP TABLE IF EXISTS `abouts`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `abouts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `html` text COLLATE utf8_unicode_ci,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `active_admin_comments`
--

DROP TABLE IF EXISTS `active_admin_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `active_admin_comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `namespace` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `body` text COLLATE utf8_unicode_ci,
  `resource_id` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `resource_type` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `author_id` int(11) DEFAULT NULL,
  `author_type` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_active_admin_comments_on_namespace` (`namespace`),
  KEY `index_active_admin_comments_on_author_type_and_author_id` (`author_type`,`author_id`),
  KEY `index_active_admin_comments_on_resource_type_and_resource_id` (`resource_type`,`resource_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `admin_users`
--

DROP TABLE IF EXISTS `admin_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `admin_users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#39;&#39;,
  `encrypted_password` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#39;&#39;,
  `reset_password_token` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `reset_password_sent_at` datetime DEFAULT NULL,
  `remember_created_at` datetime DEFAULT NULL,
  `sign_in_count` int(11) NOT NULL DEFAULT &#39;0&#39;,
  `current_sign_in_at` datetime DEFAULT NULL,
  `last_sign_in_at` datetime DEFAULT NULL,
  `current_sign_in_ip` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `last_sign_in_ip` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `index_admin_users_on_email` (`email`),
  UNIQUE KEY `index_admin_users_on_reset_password_token` (`reset_password_token`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `bottom_links`
--

DROP TABLE IF EXISTS `bottom_links`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bottom_links` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `src` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `category_link_id` int(11) DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `category_links`
--

DROP TABLE IF EXISTS `category_links`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `category_links` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `clubs`
--

DROP TABLE IF EXISTS `clubs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `clubs` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `tables_count` int(11) DEFAULT NULL,
  `description` text COLLATE utf8_unicode_ci,
  `mon_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `mon_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `tue_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `tue_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `wed_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `wed_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `thu_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `thu_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `fri_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `fri_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `sat_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `sat_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `sun_opens` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;08:00&#39;,
  `sun_closes` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;23:00&#39;,
  `user_id` int(11) DEFAULT NULL,
  `phone` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `address` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `time_before` int(11) DEFAULT NULL,
  `time_after` int(11) DEFAULT NULL,
  `time_waiting` int(11) DEFAULT NULL,
  `time_last` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `avatar` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `average_price` int(11) DEFAULT NULL,
  `city` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `rating_average` decimal(6,2) DEFAULT &#39;0.00&#39;,
  `is_certified` tinyint(1) DEFAULT &#39;0&#39;,
  `metro_station` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `site` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `email` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `additional_phones` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `payment_methods` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_clubs_on_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `clubs_properties`
--

DROP TABLE IF EXISTS `clubs_properties`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `clubs_properties` (
  `club_id` int(11) NOT NULL,
  `property_id` int(11) NOT NULL,
  KEY `index_clubs_properties_on_club_id` (`club_id`),
  KEY `index_clubs_properties_on_property_id` (`property_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `description` text COLLATE utf8_unicode_ci,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `club_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_comments_on_club_id` (`club_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `favorites`
--

DROP TABLE IF EXISTS `favorites`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `favorites` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `club_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `invites`
--

DROP TABLE IF EXISTS `invites`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `invites` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `phone` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `news`
--

DROP TABLE IF EXISTS `news`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `news` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `club_id` int(11) DEFAULT NULL,
  `description` text COLLATE utf8_unicode_ci,
  `title` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `avatar` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_news_on_club_id` (`club_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `notifications`
--

DROP TABLE IF EXISTS `notifications`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `notifications` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `phone` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `is_phone` tinyint(1) DEFAULT NULL,
  `email` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `is_email` tinyint(1) DEFAULT NULL,
  `club_id` int(11) DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `orders`
--

DROP TABLE IF EXISTS `orders`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `orders` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `table_id` int(11) DEFAULT NULL,
  `since` datetime DEFAULT NULL,
  `until` datetime DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `phone` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `token` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `time` datetime DEFAULT NULL,
  `confirmation` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `comment` text COLLATE utf8_unicode_ci,
  PRIMARY KEY (`id`),
  KEY `index_orders_on_table_id` (`table_id`),
  KEY `index_orders_on_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `photos`
--

DROP TABLE IF EXISTS `photos`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `photos` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `image` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `imageable_id` int(11) DEFAULT NULL,
  `imageable_type` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `properties`
--

DROP TABLE IF EXISTS `properties`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `properties` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name_ru` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `name_en` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `kind_ru` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `kind_en` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `rates`
--

DROP TABLE IF EXISTS `rates`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `rates` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `rater_id` int(11) DEFAULT NULL,
  `rateable_id` int(11) DEFAULT NULL,
  `rateable_type` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `stars` int(11) NOT NULL,
  `dimension` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_rates_on_rater_id` (`rater_id`),
  KEY `index_rates_on_rateable_id_and_rateable_type` (`rateable_id`,`rateable_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `schema_migrations`
--

DROP TABLE IF EXISTS `schema_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schema_migrations` (
  `version` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  UNIQUE KEY `unique_schema_migrations` (`version`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `subscribes`
--

DROP TABLE IF EXISTS `subscribes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `subscribes` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `club_id` int(11) DEFAULT NULL,
  `user_id` int(11) DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `tables`
--

DROP TABLE IF EXISTS `tables`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tables` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `club_id` int(11) DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `status_now` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;free&#39;,
  `number` int(11) DEFAULT NULL,
  `seats` int(11) DEFAULT NULL,
  `hall` varchar(255) COLLATE utf8_unicode_ci DEFAULT &#39;ÐÐµÐºÑƒÑ€ÑÑ‰Ð¸Ð¹&#39;,
  PRIMARY KEY (`id`),
  KEY `index_tables_on_club_id` (`club_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#39;&#39;,
  `encrypted_password` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT &#39;&#39;,
  `phone` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `reset_password_token` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `reset_password_sent_at` datetime DEFAULT NULL,
  `remember_created_at` datetime DEFAULT NULL,
  `sign_in_count` int(11) NOT NULL DEFAULT &#39;0&#39;,
  `current_sign_in_at` datetime DEFAULT NULL,
  `last_sign_in_at` datetime DEFAULT NULL,
  `current_sign_in_ip` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `last_sign_in_ip` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `confirmation_token` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `confirmed_at` datetime DEFAULT NULL,
  `confirmation_sent_at` datetime DEFAULT NULL,
  `unconfirmed_email` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `owner_clubs` tinyint(1) DEFAULT &#39;0&#39;,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `locale` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `avatar` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `index_users_on_email` (`email`),
  UNIQUE KEY `index_users_on_reset_password_token` (`reset_password_token`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2014-11-01 13:03:52
INSERT INTO schema_migrations (version) VALUES (&#39;20140225071243&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140225072427&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140225073248&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140225154905&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140225164357&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140226132329&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140301150509&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140301151643&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140301171114&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140301171539&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140301183747&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140305154927&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140305171847&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140305172037&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140305181214&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140309160111&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140309161752&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140310223609&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140311171120&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140312160805&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140312161407&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140313135016&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140313145024&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140315121629&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140321152717&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140321152724&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140322155522&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140324195246&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140325135054&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140325164738&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140326181322&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140326181650&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140327021321&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140330175321&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140402184931&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140409160003&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140409161250&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140410164112&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140410165620&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140410174843&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140410175538&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140411164302&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140414175748&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140414202617&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140417151847&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140417181751&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140420094422&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140420095015&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140420095716&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140420165659&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140424123311&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140424135823&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140424185110&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140425150441&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140425151925&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140428164202&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140502180500&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140503193828&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140509181041&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140524155333&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140524155452&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140524161631&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140525103554&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140525135605&#39;);

INSERT INTO schema_migrations (version) VALUES (&#39;20140526174626&#39;);
</code></pre>
</body></html>